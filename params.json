{"google":"","body":"`glitz.js` is a bare-bones, small and fast micro-framework for running 2D canvas animations.  It is designed for cases where a simple animation or special effect is called for, but where a more complete ( and heavier ) animation solution is overkill.\r\n\r\n* **No dependencies.**\r\n\r\n `glitz.js` is vanilla `javascript`.  That said, if you are using `jQuery`\r\n you can start a `glitz.Engine` like this:\r\n\r\n            var engine = new glitz.Engine( $('canvas#myCanvas') );\r\n\r\n* **Pretty Small.**\r\n\r\n Minified, `glitz.js` weighs in at `9KB ( 2.9KB gzip )`.  Even so, a quarter of \r\n that size is the 30 built-in easing algorithms.  Where maximum thinness is required, remove any unused easing equasions.\r\n\r\n* **Well mannered.**\r\n\r\n Unless there's an animation in progress, `glitz.Engine` is 100% idle.  The main animation\r\n loop and subsequent render calls are event-driven, so when there's nothing to do it *does nothing*.\r\n\r\n* **Control your FPS.**\r\n\r\n Glitz uses a render loop that allows for a configurable `FPS`, crucial for achieving subtle film & traditional animation effects:\r\n\r\n     var engine = new glitz.Engine( document.getElementById( 'myCanvas' )); \r\n     engine.fps( 24 );\r\n \r\n\r\nUSAGE\r\n----------------------------------------------------------------------------------------------------\r\n\r\n  `glitz.js` is made up of three Classes, accessed via the global namespace `glitz`  \r\n  ( note: glitz is still < 1.0, the API may be subject to rapid change )\r\n    \r\nglitz.Engine\r\n=========\r\n\r\n  `glitz.Engine` instances are initalized on the `<canvas>` tag and control the timing of an animation, store all the associated `renderables` and internally orchestrate the draw loops and framerate.  Initialize an `Engine` by passing it an `HTMLCanvasElement`.\r\n    \r\n      var engine = new glitz.Engine( document.getElementById( 'myCanvas' ));\r\n\r\n  `engines` expose some configuration methods\r\n  \r\n      engine.fps( 24 );\r\n      engine.setSize( 500, 500 );\r\n      \r\n  and include a special `Renderable` called `layout`\r\n  \r\n      engine.layout.backgroundColor = '#f00;'\r\n  \r\nglitz.Renderable\r\n=========\r\n\r\n  `glitz.Renderable` is a base class for any kind of drawable object.  Just give it a set of properties, and a `render` method.\r\n  \r\n      var square = new glitz.Renderable({\r\n          height: 100\r\n        , width:  100\r\n        , color: '#0f0'\r\n        , render: function( ctx ){\r\n            ctx.fillStyle = this.color;\r\n            ctx.fillRect( 0, 0, this.width, this.height );\r\n        }\r\n      });\r\n    \r\n  Then add it to the engine's layout\r\n\r\n      engine.layout.push( square );\r\n    \r\n  This means that `square` is now a child of the `layout` `Renderable`. All `Renderables` can have children\r\n  \r\n      var triangle = new glitz.Renderable({\r\n          height: 100\r\n        , width:  100\r\n        , color: '#0f0'\r\n        , render: function( ctx ){\r\n            ctx.fillStyle = this.color;\r\n            ctx.beginPath();\r\n            ctx.moveTo( 0, this.height );\r\n            ctx.lineTo( this.width, this.height );\r\n            ctx.lineTo( this.width * .5, 0 );\r\n            ctx.lineTo( 0, this.height );\r\n            ctx.fill();\r\n            ctx.closePath();\r\n        }\r\n      });\r\n      square.push( triangle );\r\n\r\n  In this capacity, `Renderables` act just like `Array`. Walking the tree is easy.\r\n  \r\n      square.length;        // 1\r\n      square[0];            // triangle\r\n      engine.layout[0][0];  // triangle\r\n      triangle.parent;      // square\r\n      square.parent;        // layout\r\n      square.engine;        // engine\r\n\r\nglitz.Animation\r\n=========\r\n\r\n  `glitz.Animation` instances are not usually created explicitly, but instead are handled under the hood by `renderable.animate`\r\n  \r\n      square.animate({ height: 50 }, 750 );\r\n\r\n  In addition to any custom properties, `Renderables` expose the spacial components `x`, `y,` and `scale`, all of which are applied as `transformations` to the `engine.ctx` matrix before `renerable.render`, affecting all descendent renderables.\r\n\r\n      square.animate({ x: 10, y: 25, scale: 0.8 }, 500 );\r\n      \r\n  You can also animate properties with relative transformations\r\n  \r\n      square.animate({ x: '+10', y: '-10' }, 500 );\r\n      \r\n  `Animation` has access to 30 built-in easing equations ported from Robert Penner's [`Easing Equations Library for ActionScript`](http://www.robertpenner.com/easing/)\r\n\r\n      square.animate({ width: '+50' }, { easing: 'easeInOutBounce', duration: 750 });\r\n  \r\n  and can tween colors\r\n  \r\n      square.animate({ color: '#00f' }, 1500 );\r\n      triangle.animate({ color: 'rgba(150,200,100,0.8)' }, 750 );\r\n\r\n  Right now, animations are not automatically queued and cannot be run in parallel on a single `renderable` --\r\n  each call to `renderable.animate` will cancel any running `Animation` and start the new one immediately.\r\n  Instead, pass a callback as the third parameter or as an option:\r\n  \r\n      square.animate({ width: '-25' }, 500, function(){\r\n        // or as an option\r\n        triangle.animate({ height: '+25' }, { duration: 500, done: function(){ \r\n          // done!\r\n        }});\r\n      });\r\n      \r\n  Finally, `glitz.Animation` can be used independantly to animate the properties of any object.  The target object properties are set every time `animation.step` is called.\r\n  \r\n      var foo = { bar: 0 };\r\n      var anim = new glitz.Animation( foo, { to: { bar: '+50' }, duration: 1500 });\r\n      \r\n      setTimeout(function(){\r\n        anim.step(); // true\r\n        console.log(foo.bar); // 27.8222\r\n      }, 500 );\r\n      \r\n      setTimeout(function(){\r\n        anim.step(); // true\r\n        console.log(foo.bar); // 44.46664444444445\r\n      }, 1000 );\r\n      \r\n      setTimeout(function(){\r\n        anim.step(); // false, animation is done.\r\n        console.log(foo.bar); // 50\r\n      }, 1600 );","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Glitz.js","tagline":"glitz.js is a small and fast micro-framework for running simple HTML5 canvas animations."}